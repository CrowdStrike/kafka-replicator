// Code generated by MockGen. DO NOT EDIT.
// Source: core.go

// Package tests is a generated GoMock package.
package tests

import (
	context "context"
	core "github.com/CrowdStrike/kafka-replicator/pkg/core"
	kafka "github.com/confluentinc/confluent-kafka-go/kafka"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockLifecycle is a mock of Lifecycle interface
type MockLifecycle struct {
	ctrl     *gomock.Controller
	recorder *MockLifecycleMockRecorder
}

// MockLifecycleMockRecorder is the mock recorder for MockLifecycle
type MockLifecycleMockRecorder struct {
	mock *MockLifecycle
}

// NewMockLifecycle creates a new mock instance
func NewMockLifecycle(ctrl *gomock.Controller) *MockLifecycle {
	mock := &MockLifecycle{ctrl: ctrl}
	mock.recorder = &MockLifecycleMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockLifecycle) EXPECT() *MockLifecycleMockRecorder {
	return m.recorder
}

// Start mocks base method
func (m *MockLifecycle) Start() error {
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start
func (mr *MockLifecycleMockRecorder) Start() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockLifecycle)(nil).Start))
}

// Stop mocks base method
func (m *MockLifecycle) Stop() {
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop
func (mr *MockLifecycleMockRecorder) Stop() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockLifecycle)(nil).Stop))
}

// MockFactory is a mock of Factory interface
type MockFactory struct {
	ctrl     *gomock.Controller
	recorder *MockFactoryMockRecorder
}

// MockFactoryMockRecorder is the mock recorder for MockFactory
type MockFactoryMockRecorder struct {
	mock *MockFactory
}

// NewMockFactory creates a new mock instance
func NewMockFactory(ctrl *gomock.Controller) *MockFactory {
	mock := &MockFactory{ctrl: ctrl}
	mock.recorder = &MockFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockFactory) EXPECT() *MockFactoryMockRecorder {
	return m.recorder
}

// Get mocks base method
func (m *MockFactory) Get() (interface{}, error) {
	ret := m.ctrl.Call(m, "Get")
	ret0, _ := ret[0].(interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get
func (mr *MockFactoryMockRecorder) Get() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockFactory)(nil).Get))
}

// MockBreaker is a mock of Breaker interface
type MockBreaker struct {
	ctrl     *gomock.Controller
	recorder *MockBreakerMockRecorder
}

// MockBreakerMockRecorder is the mock recorder for MockBreaker
type MockBreakerMockRecorder struct {
	mock *MockBreaker
}

// NewMockBreaker creates a new mock instance
func NewMockBreaker(ctrl *gomock.Controller) *MockBreaker {
	mock := &MockBreaker{ctrl: ctrl}
	mock.recorder = &MockBreakerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockBreaker) EXPECT() *MockBreakerMockRecorder {
	return m.recorder
}

// Mark mocks base method
func (m *MockBreaker) Mark() {
	m.ctrl.Call(m, "Mark")
}

// Mark indicates an expected call of Mark
func (mr *MockBreakerMockRecorder) Mark() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Mark", reflect.TypeOf((*MockBreaker)(nil).Mark))
}

// MockRetrier is a mock of Retrier interface
type MockRetrier struct {
	ctrl     *gomock.Controller
	recorder *MockRetrierMockRecorder
}

// MockRetrierMockRecorder is the mock recorder for MockRetrier
type MockRetrierMockRecorder struct {
	mock *MockRetrier
}

// NewMockRetrier creates a new mock instance
func NewMockRetrier(ctrl *gomock.Controller) *MockRetrier {
	mock := &MockRetrier{ctrl: ctrl}
	mock.recorder = &MockRetrierMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockRetrier) EXPECT() *MockRetrierMockRecorder {
	return m.recorder
}

// Forever mocks base method
func (m *MockRetrier) Forever(ctx context.Context, work func() error) bool {
	ret := m.ctrl.Call(m, "Forever", ctx, work)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Forever indicates an expected call of Forever
func (mr *MockRetrierMockRecorder) Forever(ctx, work interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Forever", reflect.TypeOf((*MockRetrier)(nil).Forever), ctx, work)
}

// MockSegmentStore is a mock of SegmentStore interface
type MockSegmentStore struct {
	ctrl     *gomock.Controller
	recorder *MockSegmentStoreMockRecorder
}

// MockSegmentStoreMockRecorder is the mock recorder for MockSegmentStore
type MockSegmentStoreMockRecorder struct {
	mock *MockSegmentStore
}

// NewMockSegmentStore creates a new mock instance
func NewMockSegmentStore(ctrl *gomock.Controller) *MockSegmentStore {
	mock := &MockSegmentStore{ctrl: ctrl}
	mock.recorder = &MockSegmentStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSegmentStore) EXPECT() *MockSegmentStoreMockRecorder {
	return m.recorder
}

// Events mocks base method
func (m *MockSegmentStore) Events() <-chan core.SegmentEventRequest {
	ret := m.ctrl.Call(m, "Events")
	ret0, _ := ret[0].(<-chan core.SegmentEventRequest)
	return ret0
}

// Events indicates an expected call of Events
func (mr *MockSegmentStoreMockRecorder) Events() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Events", reflect.TypeOf((*MockSegmentStore)(nil).Events))
}

// Create mocks base method
func (m *MockSegmentStore) Create(ctx context.Context) (core.SegmentWriter, error) {
	ret := m.ctrl.Call(m, "Create", ctx)
	ret0, _ := ret[0].(core.SegmentWriter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Create indicates an expected call of Create
func (mr *MockSegmentStoreMockRecorder) Create(ctx interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockSegmentStore)(nil).Create), ctx)
}

// Open mocks base method
func (m *MockSegmentStore) Open(ctx context.Context, segment core.Segment) (core.SegmentReader, error) {
	ret := m.ctrl.Call(m, "Open", ctx, segment)
	ret0, _ := ret[0].(core.SegmentReader)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Open indicates an expected call of Open
func (mr *MockSegmentStoreMockRecorder) Open(ctx, segment interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Open", reflect.TypeOf((*MockSegmentStore)(nil).Open), ctx, segment)
}

// ListSegments mocks base method
func (m *MockSegmentStore) ListSegments(ctx context.Context, region, topic string, partition uint32) (map[core.Segment]core.SegmentInfo, error) {
	ret := m.ctrl.Call(m, "ListSegments", ctx, region, topic, partition)
	ret0, _ := ret[0].(map[core.Segment]core.SegmentInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListSegments indicates an expected call of ListSegments
func (mr *MockSegmentStoreMockRecorder) ListSegments(ctx, region, topic, partition interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSegments", reflect.TypeOf((*MockSegmentStore)(nil).ListSegments), ctx, region, topic, partition)
}

// Delete mocks base method
func (m *MockSegmentStore) Delete(ctx context.Context, segment core.Segment) error {
	ret := m.ctrl.Call(m, "Delete", ctx, segment)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete
func (mr *MockSegmentStoreMockRecorder) Delete(ctx, segment interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockSegmentStore)(nil).Delete), ctx, segment)
}

// MockSegmentEventSource is a mock of SegmentEventSource interface
type MockSegmentEventSource struct {
	ctrl     *gomock.Controller
	recorder *MockSegmentEventSourceMockRecorder
}

// MockSegmentEventSourceMockRecorder is the mock recorder for MockSegmentEventSource
type MockSegmentEventSourceMockRecorder struct {
	mock *MockSegmentEventSource
}

// NewMockSegmentEventSource creates a new mock instance
func NewMockSegmentEventSource(ctrl *gomock.Controller) *MockSegmentEventSource {
	mock := &MockSegmentEventSource{ctrl: ctrl}
	mock.recorder = &MockSegmentEventSourceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSegmentEventSource) EXPECT() *MockSegmentEventSourceMockRecorder {
	return m.recorder
}

// Events mocks base method
func (m *MockSegmentEventSource) Events() <-chan core.SegmentEventRequest {
	ret := m.ctrl.Call(m, "Events")
	ret0, _ := ret[0].(<-chan core.SegmentEventRequest)
	return ret0
}

// Events indicates an expected call of Events
func (mr *MockSegmentEventSourceMockRecorder) Events() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Events", reflect.TypeOf((*MockSegmentEventSource)(nil).Events))
}

// MockSegmentWriter is a mock of SegmentWriter interface
type MockSegmentWriter struct {
	ctrl     *gomock.Controller
	recorder *MockSegmentWriterMockRecorder
}

// MockSegmentWriterMockRecorder is the mock recorder for MockSegmentWriter
type MockSegmentWriterMockRecorder struct {
	mock *MockSegmentWriter
}

// NewMockSegmentWriter creates a new mock instance
func NewMockSegmentWriter(ctrl *gomock.Controller) *MockSegmentWriter {
	mock := &MockSegmentWriter{ctrl: ctrl}
	mock.recorder = &MockSegmentWriterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSegmentWriter) EXPECT() *MockSegmentWriterMockRecorder {
	return m.recorder
}

// Write mocks base method
func (m *MockSegmentWriter) Write(ctx context.Context, message core.Message) error {
	ret := m.ctrl.Call(m, "Write", ctx, message)
	ret0, _ := ret[0].(error)
	return ret0
}

// Write indicates an expected call of Write
func (mr *MockSegmentWriterMockRecorder) Write(ctx, message interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockSegmentWriter)(nil).Write), ctx, message)
}

// Close mocks base method
func (m *MockSegmentWriter) Close(ctx context.Context, metadata core.SegmentMetadata) error {
	ret := m.ctrl.Call(m, "Close", ctx, metadata)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close
func (mr *MockSegmentWriterMockRecorder) Close(ctx, metadata interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockSegmentWriter)(nil).Close), ctx, metadata)
}

// Abort mocks base method
func (m *MockSegmentWriter) Abort(ctx context.Context) {
	m.ctrl.Call(m, "Abort", ctx)
}

// Abort indicates an expected call of Abort
func (mr *MockSegmentWriterMockRecorder) Abort(ctx interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Abort", reflect.TypeOf((*MockSegmentWriter)(nil).Abort), ctx)
}

// MockSegmentReader is a mock of SegmentReader interface
type MockSegmentReader struct {
	ctrl     *gomock.Controller
	recorder *MockSegmentReaderMockRecorder
}

// MockSegmentReaderMockRecorder is the mock recorder for MockSegmentReader
type MockSegmentReaderMockRecorder struct {
	mock *MockSegmentReader
}

// NewMockSegmentReader creates a new mock instance
func NewMockSegmentReader(ctrl *gomock.Controller) *MockSegmentReader {
	mock := &MockSegmentReader{ctrl: ctrl}
	mock.recorder = &MockSegmentReaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSegmentReader) EXPECT() *MockSegmentReaderMockRecorder {
	return m.recorder
}

// Read mocks base method
func (m *MockSegmentReader) Read(ctx context.Context, count int) ([]core.Message, error) {
	ret := m.ctrl.Call(m, "Read", ctx, count)
	ret0, _ := ret[0].([]core.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Read indicates an expected call of Read
func (mr *MockSegmentReaderMockRecorder) Read(ctx, count interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockSegmentReader)(nil).Read), ctx, count)
}

// Metadata mocks base method
func (m *MockSegmentReader) Metadata() core.SegmentMetadata {
	ret := m.ctrl.Call(m, "Metadata")
	ret0, _ := ret[0].(core.SegmentMetadata)
	return ret0
}

// Metadata indicates an expected call of Metadata
func (mr *MockSegmentReaderMockRecorder) Metadata() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Metadata", reflect.TypeOf((*MockSegmentReader)(nil).Metadata))
}

// Close mocks base method
func (m *MockSegmentReader) Close(ctx context.Context) {
	m.ctrl.Call(m, "Close", ctx)
}

// Close indicates an expected call of Close
func (mr *MockSegmentReaderMockRecorder) Close(ctx interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockSegmentReader)(nil).Close), ctx)
}

// MockSegmentFormat is a mock of SegmentFormat interface
type MockSegmentFormat struct {
	ctrl     *gomock.Controller
	recorder *MockSegmentFormatMockRecorder
}

// MockSegmentFormatMockRecorder is the mock recorder for MockSegmentFormat
type MockSegmentFormatMockRecorder struct {
	mock *MockSegmentFormat
}

// NewMockSegmentFormat creates a new mock instance
func NewMockSegmentFormat(ctrl *gomock.Controller) *MockSegmentFormat {
	mock := &MockSegmentFormat{ctrl: ctrl}
	mock.recorder = &MockSegmentFormatMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSegmentFormat) EXPECT() *MockSegmentFormatMockRecorder {
	return m.recorder
}

// NewWriter mocks base method
func (m *MockSegmentFormat) NewWriter(ctx context.Context, path string) (core.SegmentWriter, error) {
	ret := m.ctrl.Call(m, "NewWriter", ctx, path)
	ret0, _ := ret[0].(core.SegmentWriter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewWriter indicates an expected call of NewWriter
func (mr *MockSegmentFormatMockRecorder) NewWriter(ctx, path interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewWriter", reflect.TypeOf((*MockSegmentFormat)(nil).NewWriter), ctx, path)
}

// NewReader mocks base method
func (m *MockSegmentFormat) NewReader(ctx context.Context, path string) (core.SegmentReader, error) {
	ret := m.ctrl.Call(m, "NewReader", ctx, path)
	ret0, _ := ret[0].(core.SegmentReader)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewReader indicates an expected call of NewReader
func (mr *MockSegmentFormatMockRecorder) NewReader(ctx, path interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewReader", reflect.TypeOf((*MockSegmentFormat)(nil).NewReader), ctx, path)
}

// MockConsumer is a mock of Consumer interface
type MockConsumer struct {
	ctrl     *gomock.Controller
	recorder *MockConsumerMockRecorder
}

// MockConsumerMockRecorder is the mock recorder for MockConsumer
type MockConsumerMockRecorder struct {
	mock *MockConsumer
}

// NewMockConsumer creates a new mock instance
func NewMockConsumer(ctrl *gomock.Controller) *MockConsumer {
	mock := &MockConsumer{ctrl: ctrl}
	mock.recorder = &MockConsumerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockConsumer) EXPECT() *MockConsumerMockRecorder {
	return m.recorder
}

// Subscribe mocks base method
func (m *MockConsumer) Subscribe(topics ...string) error {
	varargs := []interface{}{}
	for _, a := range topics {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Subscribe indicates an expected call of Subscribe
func (mr *MockConsumerMockRecorder) Subscribe(topics ...interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockConsumer)(nil).Subscribe), topics...)
}

// Poll mocks base method
func (m *MockConsumer) Poll() kafka.Event {
	ret := m.ctrl.Call(m, "Poll")
	ret0, _ := ret[0].(kafka.Event)
	return ret0
}

// Poll indicates an expected call of Poll
func (mr *MockConsumerMockRecorder) Poll() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Poll", reflect.TypeOf((*MockConsumer)(nil).Poll))
}

// Assign mocks base method
func (m *MockConsumer) Assign(partitions []kafka.TopicPartition) error {
	ret := m.ctrl.Call(m, "Assign", partitions)
	ret0, _ := ret[0].(error)
	return ret0
}

// Assign indicates an expected call of Assign
func (mr *MockConsumerMockRecorder) Assign(partitions interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Assign", reflect.TypeOf((*MockConsumer)(nil).Assign), partitions)
}

// Unassign mocks base method
func (m *MockConsumer) Unassign() error {
	ret := m.ctrl.Call(m, "Unassign")
	ret0, _ := ret[0].(error)
	return ret0
}

// Unassign indicates an expected call of Unassign
func (mr *MockConsumerMockRecorder) Unassign() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unassign", reflect.TypeOf((*MockConsumer)(nil).Unassign))
}

// Pause mocks base method
func (m *MockConsumer) Pause(partitions []kafka.TopicPartition) error {
	ret := m.ctrl.Call(m, "Pause", partitions)
	ret0, _ := ret[0].(error)
	return ret0
}

// Pause indicates an expected call of Pause
func (mr *MockConsumerMockRecorder) Pause(partitions interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pause", reflect.TypeOf((*MockConsumer)(nil).Pause), partitions)
}

// Seek mocks base method
func (m *MockConsumer) Seek(topic string, partition uint32, offset kafka.Offset) error {
	ret := m.ctrl.Call(m, "Seek", topic, partition, offset)
	ret0, _ := ret[0].(error)
	return ret0
}

// Seek indicates an expected call of Seek
func (mr *MockConsumerMockRecorder) Seek(topic, partition, offset interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Seek", reflect.TypeOf((*MockConsumer)(nil).Seek), topic, partition, offset)
}

// Commit mocks base method
func (m *MockConsumer) Commit(topic string, partition uint32, offset kafka.Offset) error {
	ret := m.ctrl.Call(m, "Commit", topic, partition, offset)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit
func (mr *MockConsumerMockRecorder) Commit(topic, partition, offset interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockConsumer)(nil).Commit), topic, partition, offset)
}

// MockProducer is a mock of Producer interface
type MockProducer struct {
	ctrl     *gomock.Controller
	recorder *MockProducerMockRecorder
}

// MockProducerMockRecorder is the mock recorder for MockProducer
type MockProducerMockRecorder struct {
	mock *MockProducer
}

// NewMockProducer creates a new mock instance
func NewMockProducer(ctrl *gomock.Controller) *MockProducer {
	mock := &MockProducer{ctrl: ctrl}
	mock.recorder = &MockProducerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockProducer) EXPECT() *MockProducerMockRecorder {
	return m.recorder
}

// Produce mocks base method
func (m *MockProducer) Produce(topic string, key, value []byte) error {
	ret := m.ctrl.Call(m, "Produce", topic, key, value)
	ret0, _ := ret[0].(error)
	return ret0
}

// Produce indicates an expected call of Produce
func (mr *MockProducerMockRecorder) Produce(topic, key, value interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Produce", reflect.TypeOf((*MockProducer)(nil).Produce), topic, key, value)
}

// ProduceMessages mocks base method
func (m *MockProducer) ProduceMessages(topic string, partition uint32, messages ...core.Message) error {
	varargs := []interface{}{topic, partition}
	for _, a := range messages {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ProduceMessages", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ProduceMessages indicates an expected call of ProduceMessages
func (mr *MockProducerMockRecorder) ProduceMessages(topic, partition interface{}, messages ...interface{}) *gomock.Call {
	varargs := append([]interface{}{topic, partition}, messages...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProduceMessages", reflect.TypeOf((*MockProducer)(nil).ProduceMessages), varargs...)
}

// MockPubSub is a mock of PubSub interface
type MockPubSub struct {
	ctrl     *gomock.Controller
	recorder *MockPubSubMockRecorder
}

// MockPubSubMockRecorder is the mock recorder for MockPubSub
type MockPubSubMockRecorder struct {
	mock *MockPubSub
}

// NewMockPubSub creates a new mock instance
func NewMockPubSub(ctrl *gomock.Controller) *MockPubSub {
	mock := &MockPubSub{ctrl: ctrl}
	mock.recorder = &MockPubSubMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockPubSub) EXPECT() *MockPubSubMockRecorder {
	return m.recorder
}

// Subscribe mocks base method
func (m *MockPubSub) Subscribe(topic string) error {
	ret := m.ctrl.Call(m, "Subscribe", topic)
	ret0, _ := ret[0].(error)
	return ret0
}

// Subscribe indicates an expected call of Subscribe
func (mr *MockPubSubMockRecorder) Subscribe(topic interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockPubSub)(nil).Subscribe), topic)
}

// Events mocks base method
func (m *MockPubSub) Events() <-chan kafka.Event {
	ret := m.ctrl.Call(m, "Events")
	ret0, _ := ret[0].(<-chan kafka.Event)
	return ret0
}

// Events indicates an expected call of Events
func (mr *MockPubSubMockRecorder) Events() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Events", reflect.TypeOf((*MockPubSub)(nil).Events))
}

// Publish mocks base method
func (m *MockPubSub) Publish(topic string, key, value []byte) error {
	ret := m.ctrl.Call(m, "Publish", topic, key, value)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish
func (mr *MockPubSubMockRecorder) Publish(topic, key, value interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockPubSub)(nil).Publish), topic, key, value)
}

// MockCheckpointStore is a mock of CheckpointStore interface
type MockCheckpointStore struct {
	ctrl     *gomock.Controller
	recorder *MockCheckpointStoreMockRecorder
}

// MockCheckpointStoreMockRecorder is the mock recorder for MockCheckpointStore
type MockCheckpointStoreMockRecorder struct {
	mock *MockCheckpointStore
}

// NewMockCheckpointStore creates a new mock instance
func NewMockCheckpointStore(ctrl *gomock.Controller) *MockCheckpointStore {
	mock := &MockCheckpointStore{ctrl: ctrl}
	mock.recorder = &MockCheckpointStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCheckpointStore) EXPECT() *MockCheckpointStoreMockRecorder {
	return m.recorder
}

// Save mocks base method
func (m *MockCheckpointStore) Save(checkpoint core.Checkpoint) error {
	ret := m.ctrl.Call(m, "Save", checkpoint)
	ret0, _ := ret[0].(error)
	return ret0
}

// Save indicates an expected call of Save
func (mr *MockCheckpointStoreMockRecorder) Save(checkpoint interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockCheckpointStore)(nil).Save), checkpoint)
}

// Load mocks base method
func (m *MockCheckpointStore) Load(region, topic string, partition uint32) *core.Checkpoint {
	ret := m.ctrl.Call(m, "Load", region, topic, partition)
	ret0, _ := ret[0].(*core.Checkpoint)
	return ret0
}

// Load indicates an expected call of Load
func (mr *MockCheckpointStoreMockRecorder) Load(region, topic, partition interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Load", reflect.TypeOf((*MockCheckpointStore)(nil).Load), region, topic, partition)
}
